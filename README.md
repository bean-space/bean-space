# <img src="https://github.com/user-attachments/assets/ae443b93-c257-433c-ba1b-fc501ef07929" width="30" height="30"> 빈 공간 - Bean Space
 > 개발 기간: 2024.07.12 ~ 2024.08.22

## 🚀 배포 주소
- https://thebean.space

## 😎 프론트 레포지토리
- https://thebean.space

## 👩‍💻 팀원 소개

| 이무준 | 이수진 | 박주빈 | 임상은 |
| --- | --- | --- | --- |
| ![image](https://github.com/user-attachments/assets/3dc27d27-e1e9-4629-85a8-5482b352a11d) | ![image](https://github.com/user-attachments/assets/3f736701-1c2e-4600-9f6f-92475c8b43c8) | ![image](https://github.com/user-attachments/assets/6679fac0-d29c-4e0b-9982-935645cd2a4d) |![image](https://github.com/user-attachments/assets/365aa961-2cf3-4f82-82f9-f969bb00d9e2)  |
| [Moo-moo-11](https://github.com/Moo-moo-11) | [devitssu](https://github.com/devitssu) | [DanDanjoo](https://github.com/DanDanjoo) | [sangeuuun](https://github.com/sangeuuun) |

## 📖 프로젝트 개요   
프로젝트 주제는 숙박 예약 어플리케이션으로 여행, 출장, 휴가 등 다양한 이유로 숙박 시설을 사용하는 사람들을 위해서 국내의 숙박 시설을 한 눈에 확인하고 예약할 수 있는 서비스를 만들었습니다.

## ✨ 주요 기능
🌟 **공간 검색 및 예약**
- 원하는 날짜와 가격, 편의시설에 맞는 숙소를 필터링 검색

![image](https://github.com/user-attachments/assets/19a51490-2aad-4fd5-9d34-01cf7a9f5654)
- 별점 순, 가격순, 최신 등록 순, 예약 많은 순 정렬
- 쿠폰을 발급받아 할인된 가격으로 예약 가능

![image](https://github.com/user-attachments/assets/41bb71ef-7dc8-401e-a816-2d04250dcbc7)

🌟 **리뷰 작성**
- 체크아웃 시간 이후 리뷰 작성 가능
- 공간 상세 페이지에서 리뷰 확인 가능

![image](https://github.com/user-attachments/assets/e730f9ae-b82d-4fa3-a628-b17ea14e6cfb)

🌟 **호스트 기능**
- 메뉴탭에서 호스트로 전환 가능
  
<img width="709" alt="image" src="https://github.com/user-attachments/assets/5c265ddd-6cdb-46d3-92e9-78c6ec2fd07d">

- 공간 등록, 삭제, 예약확인
  
<img width="1362" alt="image" src="https://github.com/user-attachments/assets/e69ce4ce-7574-4fcb-aa46-81bef154c84e">



## 🏗 아키텍처
![image](https://github.com/user-attachments/assets/e3ab2671-0481-4556-8171-a0218724438d)

## 🛠 기술 스택
- **Front End** 

<img src="https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=white"> <img src="https://img.shields.io/badge/vite-646CFF?style=for-the-badge&logo=vite&logoColor=white"> <img src="https://img.shields.io/badge/vercel-000000?style=for-the-badge&logo=vercel&logoColor=white"> ![MUI](https://img.shields.io/badge/MUI-%230081CB.svg?style=for-the-badge&logo=mui&logoColor=white)

- **Back End** 

<img src="https://img.shields.io/badge/kotlin-7F52FF?style=for-the-badge&logo=kotlin&logoColor=white"> <img src="https://img.shields.io/badge/spring%20boot-6DB33F?style=for-the-badge&logo=springboot&logoColor=white"> <img src="https://img.shields.io/badge/gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white"> <img src="https://img.shields.io/badge/spring%20security-6DB33F?style=for-the-badge&logo=springsecurity&logoColor=white"> <img src="https://img.shields.io/badge/Spring%20Data%20JPA-6DB33F?style=for-the-badge"> <img src="https://img.shields.io/badge/Query%20Dsl-0085CA?style=for-the-badge"> ![JWT](https://img.shields.io/badge/JWT-black?style=for-the-badge&logo=JSON%20web%20tokens)
- **DB & Infra**

<img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white"> <img src="https://img.shields.io/badge/docker-2496ED?style=for-the-badge&logo=docker&logoColor=white"> <img src="https://img.shields.io/badge/redis-FF4438?style=for-the-badge&logo=redis&logoColor=white"> <img src="https://img.shields.io/badge/AWS-232F3E?style=for-the-badge&logo=amazonwebservices&logoColor=white"> <img src="https://img.shields.io/badge/github%20actions-2088FF?style=for-the-badge&logo=githubactions&logoColor=white"> <img src="https://img.shields.io/badge/grafana-F46800?style=for-the-badge&logo=grafana&logoColor=white"> <img src="https://img.shields.io/badge/loki-F46800?style=for-the-badge&logoColor=white"> <img src="https://img.shields.io/badge/prometheus-E6522C?style=for-the-badge&logo=prometheus&logoColor=white">


- **Communication** 

<img src="https://img.shields.io/badge/slack-4A154B?style=for-the-badge&logo=slack&logoColor=white"> <img src="https://img.shields.io/badge/notion-000000?style=for-the-badge&logo=notion&logoColor=white"> <img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white"> <img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">

## 기술적 의사 결정


## 트러블 슈팅
<details>
<summary><h3>CORS 문제 발생</h3></summary>

> 문제
 
클라이언트에서 서버로 요청을 보내도 CORS 정책에 의해 막혔다는 문구가 뜨면서 정상적으로 정보를 불러올 수 없었는 문제가 발생했습니다  

 
![image](https://github.com/user-attachments/assets/7ff9db09-898e-4602-862e-61b20b10deed)

> 원인

CORS 문제의 근본적인 원인은 브라우저의 SOP(동일 출처 정책, Single Origin Policy). 서버끼리 리소스 공유가 가능하도록 합의된 출처들 간에만 리소스 공유를 허용해주기위한 CORS 설정을 해주지 않았기 때문에 위의 오류가 발생하였습니다

> 해결 과정

해결법 자체는 간단한 검색만으로도 쉽게 찾을 수 있었고, 적용하는 것도 어렵지 않았습니다

단순히 해결법만 알고 넘어가기보다는 문제가 발생한 근본적인 이유를 이해하기 위해 노력하였습니다

위 문제 이후에도 S3 이미지 저장소의 PresignedUrl을 이용할 때도 CORS 문제가 발생하였는데, 원인을 알고있다보니 어디를 수정해야할지 파악하기가 쉬웠습니다. S3 저장소의 설정에 들어가서 CORS 설정만 해주면 되었습니다.

> 해결 방법

Spring Security를 이용하고 있기 때문에 SecurityConfig 파일에 있는 FilterChain에 다음과 같이 CORS 설정을 위한 코드를 추가해주는 것으로 쉽게 CORS 설정이 가능하였습니다

설정이 간단했기 때문에 아래와 같이 작성하였지만, 설정이 복잡해지거나 해당 내용을 재사용할 필요가 생기는 경우에는 따로 Config 파일을 만들어 Bean으로 등록해 사용해면 좋을 것 같습니다
 
 
```sql
@Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        return http
            .cors { cors ->
                cors.configurationSource {
                    val configuration = CorsConfiguration()
                    configuration.allowedOrigins =
                        listOf("https://bean-space-front.vercel.app/")
                    configuration.allowedMethods = listOf("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
                    configuration.allowedHeaders = listOf(
                        "X-Requested-With",
                        "Content-Type",
                        "Authorization",
                        "Origin",
                        "Accept",
                        "Access-Control-Request-Method",
                        "Access-Control-Request-Headers"
                    )
                    configuration.allowCredentials = true
                    configuration
                }
            }
            .httpBasic { it.disable() }
            // ... 중략
``` 
</details>


### 예약시 쿠폰을 넣지 않으면 오류가 발생하는 문제

> **문제**

예약할 때 유저가 쿠폰이 없을 수도 있고, 쿠폰을 적용하지 않을 수도 있는데도 불구하고 반드시 쿠폰이 있어야만 예약이 되는 문제가 발생하였습니다.
> 

> **원인**

원인은 단순히 쿠폰을 적용한 경우와 아닌 경우를 구분하여 코드를 작성해야했는데 반드시 필요하다고 가정하고 코드를 작성했기 때문입니다.
> 

> **해결 과정**

예약의 경우는 프로젝트에서 가장 핵심기능이었고 많은 예외처리와 복잡한 로직이 들어있었기 때문에 신경써야할 부분이 많았습니다.

때문에 쿠폰을 적용하고 쿠폰 적용에 맞춰 계산하는 것에 초점을 맞추다보니 쿠폰이 없는 경우를 완전히 놓치고 코드를 작성한 것을 코드 리뷰와 테스트 과정에서 발견하였습니다.

쿠폰이 없는 경우에 대해서 다시 코드를 작성함으로써 문제를 해결할 수 있었습니다.
> 

> **해결 방법**

쿠폰이 없는 경우 Request에서 쿠폰을 보내지 않게 만들었습니다.(Nullable로 만듬)

Safe Call을 활용하여 Request에서 쿠폰 ID가 null일 경우 체이닝으로 모든 호출을 건너뛰도록 코드를 작성하였습니다.

Request에 쿠폰 ID가 비어있다면 거의 모든 과정을 건너 뛰도록 코드를 작성하여 쉽게 문제를 해결할 수 있었습니다. 

```kotlin
val userCoupon = request.userCouponId?.let {
                    val couponKey = "userCoupon:$it"
                    couponLock = redissonClient.getLock(couponKey)

                    try {
                        if (!couponLock!!.tryLock(5, 10, TimeUnit.SECONDS)) {
                            throw IllegalStateException("이미 사용중인 쿠폰입니다.")
                        }
                        log.info { "LOCK COUPON KEY : $couponKey" }

                        userCouponRepository.findByIdOrNull(it)
                            ?: throw ModelNotFoundException("UserCoupon", it)
                    } catch (e: RuntimeException) {
                        couponLock?.unlock()
                        couponLock = null
                        throw e
                    }
                }?.also {
                    check(it.isCouponUnused()) { throw IllegalStateException("이미 사용한 쿠폰입니다.") }
                }?.also {
                    check(it.coupon.isNotExpired()) { throw IllegalStateException("쿠폰의 유효기간을 확인해주세요.") }
                }
```

### 삭제된 리뷰가 표시되는 문제와 리뷰 삭제 이후 리뷰 작성 가능 표시 오류 문제

> **문제**

리뷰를 삭제해도 여전히 조회되는 문제를 발견하였습니다.

또한 리뷰는 하나의 예약에 대해 하나의 리뷰만 작성 가능하도록 되어있고 정책상 리뷰 삭제 이후에 다시 리뷰 작성이 불가능했으나, 리뷰 작성 가능 여부를 조회시 리뷰 삭제 이후에도 리뷰가 작성 가능하다고 표시되는 문제가 있었습니다.
> 

> **원인**

Soft Delete를 이용해 삭제를 구현했는데 조회 과정에서 삭제 여부를 확인하지 않고 조회를 하고 있어 삭제된 리뷰가 노출되는 것이 원인이었습니다.

위의 문제가 고쳐진 이후에 다른 문제가 발생했는데, 리뷰 작성 가능 여부를 조회할 때 해당 예약에 대한 리뷰가 존재하는지를 조회하게 되는데, 이때에는 Soft Delete로 삭제된 리뷰도 조회가 되야하지만 @SQLRestriction 어노테이션을 이용해 Soft Delete를 구현하였다보니 이때에는 또 조회가 되지 않아서 리뷰가 다시 작성 가능한 것 처럼 표시되는 문제가 발생하였습니다.
> 

> **해결 과정**

먼저 리뷰를 삭제해도 여전히 리뷰가 노출되는 문제를 해결하는 건 쉽게 해결이 가능했습니다.

@SQLRestriction이라는 어노테이션을 활용하여 조회시 삭제된 리뷰가 모두 조회되지 않도록 쉽게 만들 수 있었습니다.
> 
> 
> ```kotlin
> @Entity
> @SQLRestriction("is_deleted = false")
> class Review(
>     @Column
>     var content: String,
>     
> // ...중략
> ```
> 
> 하지만 위와 같이 만들었더니 문제가 하나 생겼는데 Soft Delete로 삭제된 리뷰도 조회해야할 경우가 있었기 때문입니다.
> 
> 하나의 예약에 대해 하나의 리뷰만 작성할 수 있는데, 한 번 리뷰를 작성했다가 삭제하면 그 이후에는 리뷰를 다시 작성할 수 없도록 만들어야 했습니다.
> 
> 리뷰를 작성했는지 여부를 내보내줘야해서 해당 예약에 대해 리뷰가 있나 없나를 조회해야 했는데 @SQLRestriction 때문에 이때 리뷰가 달려있지 않다고 조회가 되는 문제가 발생했습니다.
> 
> 위 문제를 해결하기 위해서 위의 @SQLRestriction을 건너뛰고 쿼리가 발생하도록 NativeQuery를 작성하기로 하였습니다.
> 
> ```kotlin
> @Query("SELECT reservation_id FROM review WHERE reservation_id IN (:reservationIds)", nativeQuery = true)
>     fun findReservationIdsByReservationIdIn(reservationIds: List<Long>): List<Long>
> ```
> 
> 위와 같이 NativeQuery를 직접 작성하여 Soft Delete로 삭제된 리뷰도 조회가 가능하였고 정상적으로 리뷰 작성 가능 여부를 응답으로 내보낼 수 있었습니다.
> 

> **해결 방법**

@SQLRestriction 이라는 어노테이션을 이용해 삭제된 리뷰가 조회되지 않도록 만들었습니다.

위의 어노테이션을 건너뛰고 삭제된 리뷰도 조회가 되어야하는 경우에는 NativeQuery를 직접 작성하여 문제를 해결하였습니다.
> 

### 분산락 적용 이후에도 쿠폰이 초과 발급되는 문제

> **문제**

Redis를 이용한 분산락을 적용하였지만 여전히 동시성 제어 확인을 위해 만든 테스트를 통과하지 못했습니다.
> 
> 
> 락 적용 이전보다는 훨씬 나아진 결과를 보여주었지만 (200장 발급되어야할 쿠폰이 300장씩 발급 되던게 205장으로 줄어듬) 여전히 동시성 문제가 발생하였습니다.
> 
> ![fail3.PNG](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/42a3c0c7-bb21-4a8c-8ee7-fa5a9295903b/fail3.png)
> 

> **원인**
> 
> 
> 로그를 확인하니 스레드별로 락이 걸려있는건 맞으나 쿼리가 커밋되는 시점이 락이 해제된 후였습니다.
> 
> 락이 해제되고 쿼리가 커밋되는 시간 사이에 다른 스레드가 접근하게 되어 발생한 문제입니다.
> 
> 아래처럼 락이 해제되는 시점과 트랜잭션이 종료되는 시점 사이에 다른 요청이 들어오게 되면 커밋 되기 전 데이터를 조회하고 변경하게 됩니다.
> 
> ```kotlin
> **1. 트랜잭션 시작
> 
> 2. 락을 획득하는 시점
> 
> 3. 쿠폰 발급
> 
> 4. 락이 해제되는 시점
> 
> (이 짧은 찰나에 들어온 요청은 커밋이 되기 전의 데이터를 조회하게 됨)
> 
> 5 .트랜잭션 종료(커밋 시점)**
> ```
> 

> **해결 과정**
> 
> 
> 
> 먼저 문제 파악이 굉장히 어려웠습니다. 분명 결과만 보아도 동시성 제어가 되고 있는 것 같은데 일부만 실패를 하게되니 원인 파악이 쉽지 않았습니다.
> 
> 로그를 자세히 살펴보고 오랜 시간 고민과 검색 끝에 해당 문제를 파악할 수 있었습니다.
> 
> 로그를 자세히 확인하니 스레드별로 락이 걸린것은 확인되었지만 커밋 전에 락을 획득한다는 것을 알 수 있었습니다.
> 
> 트랜잭션 범위를 조정해야한다는 것을 알게되었고, 어떻게 조정할지 여러 방법을 찾아본 후에 하나를 적용해서 문제를 해결할 수 있었습니다.
> 
> 문제가 해결된 이후에는 정상적으로 미리 작성해 둔 테스트 코드가 모두 통과하였습니다.
> 
> ![success 2.PNG](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/eade9ac5-db08-4e01-bee0-e15205777c49/success_2.png)
> 

> **해결 방법**

락이 해제된 이후에 트랜잭션이 종료되고 커밋이 되도록 코드를 다시 작성하였습니다.

아래와 같이 작동하도록 코드를 수정하였습니다.
> 
> 
> ```kotlin
> 트랜잭션 시작
> 
> 락이 걸리는 시점
> 
> 트랜잭션 종료(커밋 시점)
> 
> 락이 해제되는 시점
> ```
> 
> 찾아본 결과 `TransactionTemplate`  이라는 것을 이용해 쉽게 트랜잭션 범위를 원하는 대로 만들 수 있다는 것을 알게 되었고 이것을 이용해 코드를 수정하여 문제를 해결하였습니다.
> 
> ```kotlin
> fun issueCoupon(memberId: Long, couponId: Long) {
>     val key = "coupon:$couponId"
>     val lock = redissonClient.getLock(key)
> 
>     try {
>         if (!lock.tryLock(5, 10, TimeUnit.SECONDS)) throw IllegalStateException("쿠폰 발행을 다시 시도해주세요")
> 
>         transactionTemplate.execute {
>             /*
>             쿠폰 발급 로직
>             */
>         }
>     } finally {
>         if (lock.isHeldByCurrentThread) {
>             lock.unlock()
>         }
>     }
> }
> ```
> 

### Time Zone에 의한 문제 발생

> **문제**
> 
> 
> 
> 발급 시작된 쿠폰이 발급되지 않는 문제가 발생하였습니다.
> 

> **원인**
> 
> 
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/1b057102-5187-41ce-88e2-f9f79066078a/image.png)
> 
> DB와 서버의 타임존이 일치하지 않아 발생한 문제였습니다. DB는 Asia/Seoul 타임존으로 시간이 저장되어 있었으나, 서버는 UTC를 사용하고 있어 `LocalDateTime.now()`로 시간을 체크할 때 9시간의 오차가 발생하였습니다.
> 

> **해결 과정**
> 
> 
> 서버 로그를 확인하여 쿠폰 발급 요청 시간과 로그에 기록된 시간을 비교해보니 9시간의 차이가 있는 것을 확인했습니다. 서버의 `LocalDateTime` 기준이 UTC로 설정되어 있다는 것을 파악하고, 문제 해결 방법을 찾기 시작했습니다. 스프링 부트의 기본 타임존 설정을 Asia/Seoul로 변경하면 문제가 해결된다는 것을 알게 되었고, 이를 적용하여 문제를 해결했습니다.
> 

> **해결 방법**
> 
> 
> 스프링부트의 기본 TimeZone 설정을 Asia/Seoul로 변경하여 문제를 해결하였습니다.
> 아래와 같이 코드를 작성하여 타임존을 설정할 수 있습니다.
> 
> ```kotlin
> @SpringBootApplication
> class BeanSpaceApplication
> 
> fun main(args: Array<String>) {
> 		//Default TimeZone 설정
>     TimeZone.setDefault(TimeZone.getTimeZone(ZoneId.of("Asia/Seoul")))
>     runApplication<BeanSpaceApplication>(*args)
> }
> ```
> 
> 위 코드를 적용하면 서버의 타임존이 Asia/Seoul로 설정되어 DB와 서버 간의 시간 차이가 발생하지 않게 됩니다.
> 

### 너무 느린 메인 페이지 로딩과 검색 문제

> **문제**

데이터 개수가 적을 때는 별 문제가 없었으나 더미 데이터를 만들어 데이터 양을 많이 늘렸더니 메인 페이지 로딩과 검색 기능의 성능이 느려진 게 체감되기 시작하였습니다.

배포 이후 테스트 유저 사이에서도 메인 페이지 로딩이 너무 느리다라는 피드백도 있었습니다.
> 

> **원인**

더미 데이터의 개수가 많아지니 메인 페이지에 있는 ‘가장 예약이 많은 공간 TOP4’ 부분과 검색 기능이 많이 느려져 로딩 시간이 길어졌습니다.

해당 부분들이 서비스 전체에서 가장 오랜 시간이 걸리는 쿼리들이었고 메인 기능이었기 때문에 더 눈에 띄는게 문제였습니다.

구현을 우선순위로 삼고 성능 최적화를 진행하지 않고 배포했기 때문에 위와 같은 문제가 발생하였습니다.
> 

> **해결 과정**

성능최적화의 필요성이 명확해졌기 때문에 차근차근 최적화를 진행하게 되었습니다.

먼저 불필요한 JOIN이라던가 효율적이지 못한 쿼리가 발생하지 않는지를 차근차근 살펴보게 되었습니다.

복잡한 쿼리 하나를 조금이나마 간단하게 만들 수 있었습니다.

그런 다음 인덱스를 만들어 조회 성능을 끌어올릴 수 있는지 적용해보고 테스트하는 시간을 가졌습니다.

그리고 자주 데이터가 변하지 않는 부분에 대해서는 캐시 도입을 고려하였고, 캐시를 도입하여 성능을 크게 향상 시킬 수 있었습니다.
> 

> **해결 방법**

QueryDsl로 작성한 쿼리들을 직접 확인하여 어떤 쿼리들이 발생하는지를 쭉 살펴보았습니다.

그 중에서 어떤 쿼리가 오래 걸리는지 파악한 뒤 해당 쿼리들을 수정하기도 했고, 쿼리를 보면서 자주 발생하는 쿼리와 오래 걸리는 쿼리에 인덱스를 적용하여 쿼리 성능을 크게 끌어올릴 수 있었습니다.

예시) 자주 발생하는 쿼리들
> 
> 
> ```sql
> SELECT DISTINCT s.id, AVG(r.rating) AS rating
>   FROM space s
>      LEFT JOIN review r ON r.space_id = s.id AND r.is_deleted = false
> WHERE s.status = 'ACTIVE'
>   AND s.id NOT IN (
>     SELECT space_id
>     FROM reservation
>     WHERE check_in < '2024-08-18'
>        AND check_out > '2024-08-17'
>        AND is_cancelled = false
>         )
>   AND s.max_people >= 1
>   AND s.is_deleted = false
> GROUP BY s.id
> ORDER BY rating DESC, s.id DESC;
> ```
> 
> ```sql
> SELECT DISTINCT s.id, COUNT(r.id) AS count
> FROM space s
>   LEFT JOIN reservation r ON r.space_id = s.id
>     AND r.is_cancelled = false
>     AND r.created_at >= '2024-08-09'
> WHERE s.status = 'ACTIVE'
>   AND s.id NOT IN (
>     SELECT r2.space_id
>     FROM reservation r2
>     WHERE r2.check_in < '2024-08-18'
>        AND r2.check_out > '2024-08-17'
>     AND r2.is_cancelled = false
> )
>   AND s.max_people >= 1
>   AND s.is_deleted = false
> GROUP BY s.id
> ORDER BY count, s.id DESC;
> ```
> 
> 아래 처럼 실행 계획도 확인하여 인덱스가 잘 활용되고 있는지도 확인하였습니다.
> 
> ![hh.PNG](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/cf8d84a5-1028-40fb-911a-212eb1ed7eb0/hh.png)
> 
> 또한 자주 변하지 않는 부분인 메인페이지의 ‘최근 일주일 가장 예약이 많은 숙소 TOP4’에는 스케줄러를 이용해서 일정 시간마다 캐시를 업데이트 시켜주고 조회할 때는 캐시에서 불러오는 식으로 만들어 크게 끌어올릴 수 있었습니다.
> 
> ***성능 최적화 이전 평균 응답 시간**
> 
> 검색 기능: 1.01 초
> 가장 예약 많은 숙소 TOP 4: 1.41 초*
> 
> ***성능 최적화 이후 평균 응답 시간**
> 
> 검색 기능: 0.42 초 (1.01초 → 0.42초) **약 60% 응답시간 감소**
> 가장 예약 많은 숙소 TOP 4: 0.281초 (1.41초 → 0.281초) **약 80% 응답시간 감소***
> 
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/351c4fa2-2517-4432-b1ba-e4d065eb5543/image.png)
> 
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/1a501027-4392-446d-857b-ca4f251858bb/image.png)
> 

### Email 인증 안해서 도메인 정지된 문제

> **문제**

사이트 배포가 완료되고 유저 테스트를 진행하던 중 새벽에 갑자기 사이트 접속이 불가능한 문제가 발생하였습니다.
> 

> **원인**
> 
> 
> 
> Route 53에 새 도메인을 등록하는 경우 등록자의 E-mail 주소가 유효한지 확인이 필요합니다. AWS에서 확인을 위한 이메일 링크를 보내주는데 15일 안에 이 링크를 클릭하지 않으면 도메인이 일시 중지 됩니다.
> 
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/2b2ad091-eb13-4df4-a65f-cbd71ed025aa/image.png)
> 
> 이 부분을 놓쳐서 도메인이 일시 중지되어 사이트 접속이 불가능하였습니다.
> 

> **해결 과정**

갑자기 사이트에 접속이 불가능했고, 서버는 정상적으로 동작중이었기 때문에 원인을 파악하기가 쉽지 않았습니다.

사이트에 접속하면 ‘DNS_PROBE_FINISHED_NXDOMAIN’라는 문구가 떴고 해당 문구는 도메인 이름을 IP 주소로 변환할 수 없을 때 발생한다는 것을 힌트로 삼아 문제를 찾기 시작하였습니다.

원인을 파악하기 위해 AWS 이곳저곳에 접속하는 등 꽤 오랜 시간을 보내던 와중에 Route 53에 접속했다가 E-mail 미인증으로 인해 도메인이 Suspension(일시 중지) 되었다는 문구를 발견할 수 있었습니다.

E-mail 재발송을 요청한 뒤 인증하였더니 문제를 쉽게 해결할 수 있었습니다.
> 
> 
> 
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/c3baeeb8-072d-4fc2-8664-0fd1f8b13588/image.png)
> 

> **해결 방법**

E-mail 재발송을 요청한 뒤 인증하였더니 1시간 안으로 도메인이 복구 되었습니다.
****
> 
> 
> ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/4eb72d07-1f7b-4652-abf8-6373492e5970/image.png)
> 

### 502 BadGateway

> **문제**
> 
> 
> 서버 배포후 접속을 시도했으나 502 BadGateway 오류가 발생하였습니다.
> 

> **원인**
> 
> 
> Nginx 설정 문제였습니다. Elastic Beanstalk 생성시 Docker 기반으로 플랫폼을 설정하면서 `proxy_pass`가 `http://docker`로 지정되어 있었고, Nginx가 이 대상을 찾지 못해 오류가 발생했습니다.
> 

> **해결 과정**
> 
> 
> 502 Bad Gateway 오류 메시지를 통해 Nginx가 관련된 문제임을 알게 되었습니다. Nginx를 별도로 설치하지 않았기 때문에 왜 이 오류가 발생했는지 확인해보니, AWS Elastic Beanstalk로 EC2를 설정할 때 기본적으로 Nginx가 설치된 것이 원인이었습니다. Nginx 설정 문제임을 인지하고 설정 파일을 확인했습니다. 기본 설정 파일 내용은 아래와 같았습니다.
> 
> ```
> ...
> server {
>         listen 80 default_server;
>         gzip on;
>         gzip_comp_level 4;
>         gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
> 
>         access_log    /var/log/nginx/access.log main;
> 
>         location / {
>             proxy_pass            http://docker;
>             proxy_http_version    1.1;
>             proxy_set_header    Connection             $connection_upgrade;
>             proxy_set_header    Upgrade                $http_upgrade;
>             proxy_set_header    Host                   $host;
>             proxy_set_header    X-Real-IP              $remote_addr;
>             proxy_set_header    X-Forwarded-For        $proxy_add_x_forwarded_for;
>         }
>     ...
> ```
> 
> `proxy_pass` 가 `http://docker` 로 되어있었습니다.
> 

> **해결 방법**
> 
> 
> Docker 컨테이너를 실행할 때 `docker run -p 5000:8080` 명령어를 사용해 Tomcat의 8080 포트를 외부의 5000 포트로 연결했습니다. 이후, Nginx 설정 파일의 `proxy_pass` 값을 `http://localhost:5000`으로 수정했습니다.
> 
> ```
> ...
> server {
>         listen 80 default_server;
>         gzip on;
>         gzip_comp_level 4;
>         gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
> 
>         access_log    /var/log/nginx/access.log main;
> 
>         location / {
>             proxy_pass            http://localhost:5000;
>             proxy_http_version    1.1;
>             proxy_set_header    Connection             $connection_upgrade;
>             proxy_set_header    Upgrade                $http_upgrade;
>             proxy_set_header    Host                   $host;
>             proxy_set_header    X-Real-IP              $remote_addr;
>             proxy_set_header    X-Forwarded-For        $proxy_add_x_forwarded_for;
>         }
>     ...
> ```
> 
> 이렇게 설정함으로써 로드 밸런서를 통해 들어온 HTTP 요청이 Nginx를 거쳐 `http://localhost:5000`으로 전달되었고, Docker 컨테이너 내의 Spring 애플리케이션으로 요청이 도달하게 되었습니다. 이후 502 Bad Gateway 오류는 발생하지 않았습니다.
> 

### 배포 이후 피드백 과정에서 해결한 문제들

> **문제**

유저 테스트 피드백에 많은 버그들이 제보되었습니다

프론트
- 날짜 선택을 위한 캘린더가 제대로 작동하지 않는 문제
- 엔터키를 이용해 검색이 불가능한 문제
- 정렬 기준을 바꾸어도 페이지가 1로 돌아오지 않는 문제
- 기타 등등

백엔드
- 이미지가 필수가 아님에도 이미지가 없으면 리뷰가 작성되지 않는 문제
- 회원 가입시 이미지 업로드에 실패하는 문제
- 예약 금액이 너무 높아지면 오버플로우가 발생하는 문제
> 
> 
> ![312.PNG](https://prod-files-secure.s3.us-west-2.amazonaws.com/df9ec1cb-7780-4165-a1d3-15a865604475/70cd771c-dd12-4385-af44-ef497f2c94d2/312.png)
> 

> **원인**

근본적인 원인은 배포 이전 면밀하게 테스트 전체를 돌면서 테스트하지 못해 버그들을 미처 발견하지 못했기 때문입니다.

배포 직전까지도 수정을 거듭했기 때문에 시간이 빠듯했던 것도 원인 중 하나입니다.

유효성 검사의 경우에는 하루 날을 잡아 전체적으로 점검을 했음에도 불구하고, 여러 구멍이 발견되었습니다. 팀 차원에서 더 꼼꼼하게 살펴보고 회의하는 시간을 가졌어야 하지 않았나 하는 아쉬움도 있었습니다.
> 

> **해결 과정**

프론트에는 정말 많은 문제들이 발생하였는데 전부 고치기는 어려웠지만 최대한 고칠 수 있는 부분을 수정하였습니다. 유저의 의견을 최대한 반영해서 유저가 편하게 느낄 수 있도록 힘썼습니다.

*- 이미지가 필수가 아님에도 이미지가 없으면 리뷰가 작성되지 않는 문제*

이미지가 필수가 아니었는데 이미지가 없으면 리뷰가 작성되지 않는 문제가 있다는 피드백이 들어와서 확인해보게 되었습니다. 알고보니 AddReviewRequest 쪽에 이미지부분에@NotEmpty 어노테이션이 걸려있다는 것을 알 수 있었습니다.

해당 부분을 제거하고 이미지가 없이도 리뷰를 등록할 수 있도록 수정하였습니다.

*- 회원 가입시 이미지 업로드에 실패하는 문제*

저희 서비스에는 공간 사진과 리뷰 사진, 프로필 사진등 사진이 여기저기서 이용되는데, PresignedUrl 발급에는 인증이 반드시 필요한 경우만 있다고 생각하여 해당 URI에 요청을 보낼 때 인증이 필요하도록 만든 것이 문제였습니다.

때문에 아직 인증이 되지 않은 회원가입을 시도하려는 유저가 프로필 사진을 회원가입 시에 업로드 하려고 할 때 문제가 발생했던 것이었습니다.

PresignedUrl 발급시 인증이 필요없도록 수정하여 문제를 해결할 수 있었습니다.

*- 예약 금액이 너무 높아지면 오버플로우가 발생하는 문제*

저희가 예약 금액을 계산하는 로직에서 분명 모든 부분을 Long 형으로 변환하는 등 처리를 해놓았기 때문에 오버 플로우가 발생할 수 없다고 생각했는데 유저 테스트에서 이런 경우가 발생하는 것을 확인할 수 있었습니다.

확인 결과 예약 금액을 계산하는 과정 중간에 Int로 계산되는 부분이 있음을 발견하게 되었고 해당 부분에 toLong()을 추가하여 Long 형으로 변환하여 계산하도록 만들어 문제를 해결할 수 있었습니다.
****
> 

> **해결 방법**

프론트의 경우 문제 해결 방법을 자세히 적지는 않겠습니다.

*****- 이미지가 필수가 아님에도 이미지가 없으면 리뷰가 작성되지 않는 문제*

@NotEmpty 어노테이션을 삭제하여 문제를 해결할 수 있었습니다.
****
> 
> 
> ```kotlin
> @field:Size(max = 3, message = "리뷰 이미지는 최대 3개까지 가능합니다.")
> val imageUrlList: List<String>,
> ```
> 
> *- 회원 가입시 이미지 업로드에 실패하는 문제*
> 
> presignedUrl 발급시 인증이 필요없도록 변경하여 문제를 해결할 수 있었습니다.
> 
> SecurityConfig의 RequestMatches에 presignedUrl 발급을 위한 URI를 추가하였습니다.
> 
> ```kotlin
> .requestMatchers(
>                         "/healthcheck",
>                         "/swagger-ui/**",
>                         "/v3/api-docs/**",
>                         "/api/v1/auth/sign-up",
>                         "/api/v1/auth/login",
>                         "/error",
>                         "/api/v1/spaces/**",
>                         "/oauth2/login/**",
>                         "/actuator/prometheus",
>                         "/api/v1/images/presigned-url"
>                     ).permitAll()
> ```
> 
> *- 예약 금액이 너무 높아지면 오버플로우가 발생하는 문제*
> 
> 아래 코드에 원래 toLong()이 없었는데 그 부분에서 가격이 너무 높아지면 Int 형 범위를 벗어나 오버플로우가 발생하는 문제가 있었습니다.
> 
> 계산 중간에 Int 형이 없도록 신경써서 처음에 코드를 작성했음에도 미처 발견하지 못해서 아쉬움이 남았습니다.
> 
> ```kotlin
> fun calculateTotalCost(headCount: Int, stayDays: Long): Long {
>         return (this.price + (headCount - this.defaultPeople).coerceAtLeast(0) * this.pricePerPerson.toLong()) * stayDays
>     }
> ```
>

## 📂 프로젝트 구조

```
├── BeanSpaceApplication.kt
├── api
│   ├── HealthCheckController.kt
│   ├── admin
│   │   ├── AdminController.kt
│   │   ├── AdminService.kt
│   │   └── dto
│   │       ├── RequestAddSpaceResponse.kt
│   │       └── UpdateSpaceStatus.kt
│   ├── auth
│   │   ├── AuthController.kt
│   │   ├── AuthService.kt
│   │   └── dto
│   │       ├── GetNewAccessTokenRequest.kt
│   │       ├── LoginRequest.kt
│   │       ├── LoginResponse.kt
│   │       └── SignUpRequest.kt
│   ├── coupon
│   │   ├── CouponController.kt
│   │   ├── CouponService.kt
│   │   └── dto
│   │       ├── CouponRequest.kt
│   │       ├── CouponResponse.kt
│   │       └── UserCouponResponse.kt
│   ├── host
│   │   ├── HostController.kt
│   │   ├── HostService.kt
│   │   └── dto
│   │       ├── AddSpaceRequest.kt
│   │       └── UpdateSpaceRequest.kt
│   ├── image
│   │   ├── ImageController.kt
│   │   ├── ImageService.kt
│   │   └── dto
│   │       ├── PreSignedUrlRequest.kt
│   │       └── PreSignedUrlResponse.kt
│   ├── member
│   │   ├── MemberController.kt
│   │   ├── MemberService.kt
│   │   └── dto
│   │       ├── MemberProfileResponse.kt
│   │       ├── MemberReservationResponse.kt
│   │       ├── UpdateProfileRequest.kt
│   │       └── UpdateSocialUserInfoRequest.kt
│   ├── oauth
│   │   ├── KakaoOAuth2Client.kt
│   │   ├── OAuth2LoginController.kt
│   │   ├── OAuth2LoginService.kt
│   │   └── dto
│   │       ├── KakaoLoginUserInfoResponse.kt
│   │       ├── KakaoTokenResponse.kt
│   │       └── KakaoUserPropertiesResponse.kt
│   ├── reservation
│   │   ├── ReservationController.kt
│   │   ├── ReservationService.kt
│   │   └── dto
│   │       ├── ReservationRequest.kt
│   │       └── ReservationResponse.kt
│   └── space
│       ├── SpaceController.kt
│       ├── SpaceService.kt
│       └── dto
│           ├── AddReviewRequest.kt
│           ├── CompactSpaceResponse.kt
│           ├── HostResponse.kt
│           ├── OfferResponse.kt
│           ├── PopularKeywordsResponse.kt
│           ├── ReviewResponse.kt
│           ├── SpaceDetailResponse.kt
│           ├── SpaceResponse.kt
│           ├── SpaceResponseWithoutAddress.kt
│           └── UpdateReviewRequest.kt
├── domain
│   ├── common
│   │   └── BaseTimeEntity.kt
│   ├── coupon
│   │   ├── model
│   │   │   ├── Coupon.kt
│   │   │   └── UserCoupon.kt
│   │   └── repository
│   │       ├── CouponRepository.kt
│   │       ├── CouponRepositoryImpl.kt
│   │       ├── CustomCouponRepository.kt
│   │       ├── CustomUserCouponRepository.kt
│   │       ├── UserCouponRepository.kt
│   │       └── UserCouponRepositoryImpl.kt
│   ├── exception
│   │   ├── AuthenticationException.kt
│   │   ├── GlobalExceptionHandler.kt
│   │   ├── InvalidImageException.kt
│   │   ├── ModelNotFoundException.kt
│   │   ├── NoPermissionException.kt
│   │   └── dto
│   │       └── ErrorResponse.kt
│   ├── image
│   │   ├── model
│   │   │   ├── Image.kt
│   │   │   └── ImageType.kt
│   │   └── repository
│   │       └── ImageRepository.kt
│   ├── member
│   │   ├── model
│   │   │   ├── Member.kt
│   │   │   └── MemberRole.kt
│   │   └── repository
│   │       └── MemberRepository.kt
│   ├── reservation
│   │   ├── model
│   │   │   └── Reservation.kt
│   │   └── repository
│   │       └── ReservationRepository.kt
│   └── space
│       ├── model
│       │   ├── Address.kt
│       │   ├── Offer.kt
│       │   ├── Review.kt
│       │   ├── SearchKeyword.kt
│       │   ├── Space.kt
│       │   ├── SpaceOffer.kt
│       │   ├── SpaceStatus.kt
│       │   └── Wishlist.kt
│       └── repository
│           ├── OfferRepository.kt
│           ├── ReviewRepository.kt
│           ├── SearchKeywordQueryDslRepository.kt
│           ├── SearchKeywordQueryDslRepositoryImpl.kt
│           ├── SearchKeywordRepository.kt
│           ├── SpaceOfferRepository.kt
│           ├── SpaceQueryDslRepository.kt
│           ├── SpaceQueryDslRepositoryImpl.kt
│           ├── SpaceRepository.kt
│           └── WishListRepository.kt
└── infra
    ├── log
    │   └── LogFilter.kt
    ├── querydsl
    │   └── QueryDslConfig.kt
    ├── redis
    │   ├── RedisConfig.kt
    │   └── RedisUtils.kt
    ├── restclient
    │   └── RestClientConfig.kt
    ├── s3
    │   ├── S3Config.kt
    │   ├── S3Service.kt
    │   └── imagevalidator
    │       ├── ImageValidator.kt
    │       └── ValidationResult.kt
    ├── security
    │   ├── CustomAccessDeniedHandler.kt
    │   ├── CustomAuthenticationEntrypoint.kt
    │   ├── config
    │   │   ├── PasswordEncoderConfig.kt
    │   │   └── SecurityConfig.kt
    │   ├── dto
    │   │   └── UserPrincipal.kt
    │   └── jwt
    │       ├── JwtAuthenticationFilter.kt
    │       ├── JwtAuthenticationToken.kt
    │       └── JwtPlugin.kt
    └── swagger
        └── SwaggerConfig.kt
```

## 📌 환경설정
- Language: Kotlin
- IDE: Intellij, VSCode
- SDK: Eclipse Temurin 18.0.2

## 📜 라이선스
이 프로젝트는 MIT 라이선스를 따릅니다. 자세한 내용은 [LICENSE](https://github.com/bean-space/bean-space-front/blob/dev/LICENSE) 파일을 참고하세요.
