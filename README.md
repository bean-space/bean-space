# <img src="https://github.com/user-attachments/assets/ae443b93-c257-433c-ba1b-fc501ef07929" width="30" height="30"> 빈 공간 - Bean Space
 > 개발 기간: 2024.07.12 ~ 2024.08.22

## 🚀 배포 주소
- https://thebean.space

## 😎 프론트 레포지토리
- https://github.com/bean-space/bean-space-front

## 👩‍💻 팀원 소개

| 이무준 | 이수진 | 박주빈 | 임상은 |
| --- | --- | --- | --- |
| ![image](https://github.com/user-attachments/assets/3dc27d27-e1e9-4629-85a8-5482b352a11d) | ![image](https://github.com/user-attachments/assets/3f736701-1c2e-4600-9f6f-92475c8b43c8) | ![image](https://github.com/user-attachments/assets/6679fac0-d29c-4e0b-9982-935645cd2a4d) |![image](https://github.com/user-attachments/assets/365aa961-2cf3-4f82-82f9-f969bb00d9e2)  |
| [Moo-moo-11](https://github.com/Moo-moo-11) | [devitssu](https://github.com/devitssu) | [DanDanjoo](https://github.com/DanDanjoo) | [sangeuuun](https://github.com/sangeuuun) |

## 📖 프로젝트 개요   
프로젝트 주제는 숙박 예약 어플리케이션으로 여행, 출장, 휴가 등 다양한 이유로 숙박 시설을 사용하는 사람들을 위해서 국내의 숙박 시설을 한 눈에 확인하고 예약할 수 있는 서비스를 만들었습니다.

## ✨ 주요 기능
🌟 **공간 검색 및 예약**
- 원하는 날짜와 가격, 편의시설에 맞는 숙소를 필터링 검색

![image](https://github.com/user-attachments/assets/19a51490-2aad-4fd5-9d34-01cf7a9f5654)
- 별점 순, 가격순, 최신 등록 순, 예약 많은 순 정렬
- 쿠폰을 발급받아 할인된 가격으로 예약 가능

![image](https://github.com/user-attachments/assets/41bb71ef-7dc8-401e-a816-2d04250dcbc7)

🌟 **리뷰 작성**
- 체크아웃 시간 이후 리뷰 작성 가능
- 공간 상세 페이지에서 리뷰 확인 가능

![image](https://github.com/user-attachments/assets/e730f9ae-b82d-4fa3-a628-b17ea14e6cfb)

🌟 **호스트 기능**
- 메뉴탭에서 호스트로 전환 가능
  
<img width="709" alt="image" src="https://github.com/user-attachments/assets/5c265ddd-6cdb-46d3-92e9-78c6ec2fd07d">

- 공간 등록, 삭제, 예약확인
  
<img width="1362" alt="image" src="https://github.com/user-attachments/assets/e69ce4ce-7574-4fcb-aa46-81bef154c84e">



## 🏗 아키텍처
![image](https://github.com/user-attachments/assets/e3ab2671-0481-4556-8171-a0218724438d)

## 🛠 기술 스택
- **Front End** 

<img src="https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=white"> <img src="https://img.shields.io/badge/vite-646CFF?style=for-the-badge&logo=vite&logoColor=white"> <img src="https://img.shields.io/badge/vercel-000000?style=for-the-badge&logo=vercel&logoColor=white"> ![MUI](https://img.shields.io/badge/MUI-%230081CB.svg?style=for-the-badge&logo=mui&logoColor=white)

- **Back End** 

<img src="https://img.shields.io/badge/kotlin-7F52FF?style=for-the-badge&logo=kotlin&logoColor=white"> <img src="https://img.shields.io/badge/spring%20boot-6DB33F?style=for-the-badge&logo=springboot&logoColor=white"> <img src="https://img.shields.io/badge/gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white"> <img src="https://img.shields.io/badge/spring%20security-6DB33F?style=for-the-badge&logo=springsecurity&logoColor=white"> <img src="https://img.shields.io/badge/Spring%20Data%20JPA-6DB33F?style=for-the-badge"> <img src="https://img.shields.io/badge/Query%20Dsl-0085CA?style=for-the-badge"> ![JWT](https://img.shields.io/badge/JWT-black?style=for-the-badge&logo=JSON%20web%20tokens)
- **DB & Infra**

<img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white"> <img src="https://img.shields.io/badge/docker-2496ED?style=for-the-badge&logo=docker&logoColor=white"> <img src="https://img.shields.io/badge/redis-FF4438?style=for-the-badge&logo=redis&logoColor=white"> <img src="https://img.shields.io/badge/AWS-232F3E?style=for-the-badge&logo=amazonwebservices&logoColor=white"> <img src="https://img.shields.io/badge/github%20actions-2088FF?style=for-the-badge&logo=githubactions&logoColor=white"> <img src="https://img.shields.io/badge/grafana-F46800?style=for-the-badge&logo=grafana&logoColor=white"> <img src="https://img.shields.io/badge/loki-F46800?style=for-the-badge&logoColor=white"> <img src="https://img.shields.io/badge/prometheus-E6522C?style=for-the-badge&logo=prometheus&logoColor=white">


- **Communication** 

<img src="https://img.shields.io/badge/slack-4A154B?style=for-the-badge&logo=slack&logoColor=white"> <img src="https://img.shields.io/badge/notion-000000?style=for-the-badge&logo=notion&logoColor=white"> <img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white"> <img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">

## 기술적 의사 결정

<details>
<summary><h3>첫 소셜로그인시 전화번호 정보를 어떻게 받을 것인지?</h3></summary>

> **도입**

카카오 소셜 로그인에서는 전화번호 정보를 직접 가져올 수 없기 때문에, 추가적인 정보 수집이 필요한 상황에서 이를 해결할 수 있는 방법이 필요했습니다.


> **문제 상황**

호스트와의 연락 및 신원 보증 수단으로 전화번호가 반드시 필요했지만, 카카오 API에서 전화번호와 같은 개인정보를 받아오려면 사업자 등록이 필수였습니다.

따라서 소셜 회원가입을 진행한 회원들에게 추가로 전화번호를 입력할 수 있는 별도의 방법이 필요했습니다.


> **의견 조율**

초기 아이디어는 소셜 로그인 이용시 사용자가 이미 가입이 된 상태라면 서버의 Access Token을 전달하면 되고, 그렇지 않은 경우에는 카카오에서 가져온 유저 정보를 넘긴 후 추가 정보 입력 창으로 연결하는 구조를 떠올렸습니다.

이를 위해 컨트롤러의 반환 타입을 ‘any’로 지정하고 DTO를 다르게 넘겨주는 방법도 떠올렸었고, 아예 분리된 API를 만들어서 프론트엔드와 연결하는 방식도 떠올렸으나, 이러한 접근이 효율적인지, 어떻게 구현해야하는지 판단이 어려워 튜터님의 의견을 구해보기로 했습니다.

****튜터님에게 의견을 구한 결과, 전화번호를 꼭 회원가입시에 받아야 하는지 의문이 들고, 전화번호가 필요한 순간(예: 예약 진행시)에 추가 정보를 받는 것이 사용자 경험에서도 더 자연스럽고 어색하지 않은 것 같다라는 답변을 들을 수 있었습니다.

모든 정보를 회원 가입 시에 한 번에 받아 처리하려다보니 설계가 복잡해지고 비효율적인 접근이 되고 있는게 아니냐라고 지적해주셨습니다.

이를 바탕으로 팀원들과 논의한 결과, 소셜 로그인을 이용한 회원가입과 추가 정보 입력 과정을 아예 분리하기로 결정하고, 그에 맞춰 구현하였습니다.


> **결정**

소셜 회원 가입시 전화번호와 같은 정보가 없는 칼럼들은 일단 “EMPTY”라는 문자열이 들어가도록 처리하였습니다.

이후, 전화번호 정보가 없는 유저가 전화번호 입력이 필요한 시점(예약 페이지 접근 시)에 전화번호 정보를 입력하는 페이지로 이동시켜 주어 전화번호를 저장할 수 있게끔 로직을 설계하였습니다.

이것을 구현하기 위해, 프로필 정보를 추가로 입력할 수 있는 API를 만들었고, 프론트와 백엔드 간의 연결도 완료할 수 있었습니다. 이렇게 사용자 경험까지 고려한 효율적인 정보 수집 방식을 도입할 수 있었습니다.

</details>

<details>
<summary><h3>이미지 저장에 활용할 S3 저장소를 어떤 방식으로 이용할 것인지?</h3></summary>


> **배경 및 문제 상황**

이미지 저장소로 S3를 활용하기로 이미 결정된 상태였습니다. 그런 다음 이미지 업로드를 어떤 방식으로 할지 다음 2가지 중 하나로 결정해야했습니다.

1. MultiPartFile을 서버를 통해 받아서 S3에 저장
2. Presigned URL을 이용하여 클라이언트에서 직접 S3로 업로드

이 두 방식의 장단점을 비교한 후, 어떤 방식을 선택할지 결정을 내려야 했습니다.


> **두 방식의 장단점**

- MultiPartFile을 통한 서버 업로드 : 
    - 서버에서 이미지를 받아서 S3에 직접 업로드하기 때문에 서버에서 유효성 검사와 같은 추가 작업을 처리할 수 있다는 장점이 있습니다.
    - 하지만 처리해야할 이미지의 용량과 양이 늘면 서버의 부하가 증가할 수 있다는 단점이 있습니다.

- Presigned URL : 
    - 클라이언트가 서버를 거치지 않고 직접 S3에 이미지를 업로드 할 수 있기 때문에 서버의 부하를 줄일 수 있다는 큰 장점이 있습니다.
    - 이미지 업로드 과정이 굉장히 복잡해지고 프론트엔드 작업의 복잡성이 크게 증가합니다. 오히려 백엔드에서는 할 일이 크게 줄어듭니다.


> **의견 조율**

해당 부분은 팀원들 모두가 익숙하지 않은 부분이어서 어떤 것이 더 좋은지 판단하기 어려웠습니다.

프로젝트 초기 단계에 이 이미지 업로드를 위한 백엔드 작업을 시작했을 당시, 프론트엔드도 직접 구현해야 했기 때문에, 복잡한 Presigned URL을 이용한 방식을 프론트에서 잘 구현할 수 있을지에 대한 우려가 상당히 컸습니다.

결국, 결정을 미루기로 하고 두 방식을 모두 백엔드에서 일단 구현해 놓기로 결정했습니다. 고민하는 시간을 줄이고 일단 구현해놓고 프론트를 구현하면서 다시 생각해보는 게 좋을 것 같다는 것이 저희의 판단이었습니다.

그렇게 모두 백엔드에서 구현을 해놓고 나서 몇 주 후 프론트 작업을 하면서 최종적으로 결정을 할 수 있었습니다.

프론트 구현 과정에서 Presigne URL을 이용한 이미지 업로드에 큰 어려움 없이 성공적으로 구현할 수 있었습니다. 때문에 서버의 부하를 줄여줄 수 있는 Presigned URL을 이용하기로 쉽게 결정할 수 있었습니다.

이처럼 프로젝트 진척에 따라서 결정을 잠시 유보하는 것도 좋은 판단이었다는 생각이 듭니다.


> **결정**

최종 결정은 Presigned URL을 이용하기로 결정하였습니다. 서버 부하가 줄어든다는 큰 장점이 있었고, 다소 복잡한 업로드 과정이 걱정되었지만 프론트 구현 과정에서도 성공적으로 구현할 수 있어서 Presigned URL을 이용하는 방식으로 최종 결정하였습니다.

</details>

<details>
<summary><h3>동시성 제어가 필요한 이유와 Redis를 이용한 분산락을 적용한 이유?</h3></summary>

> **도입** 

쿠폰 발급이나 예약 같은 기능에서는 많은 사용자가 동시에 요청을 보낼 수 있습니다.

여러 사용자가 동시에 쿠폰 발급을 시도하면 동시성 문제로 인해 쿠폰이 중복 발급되거나 예약이 같은 기간에 중복될 수 있습니다. 이런 경쟁 상태(Race condition)을 방지하기 위해 동시성 제어가 필요했습니다.

쿠폰 발급 시, 발급 가능한 수량이 한정되어 있기 때문에, 동시 요청으로 인해 발급 가능 수량을 초과하여 쿠폰이 발급되는 문제도 방지해야 합니다. 정확한 재고 관리를 위해 동시성 제어가 필요했습니다.

위와 같은 상황을 방지하기 위해 락 적용을 고려하게 되었고, 그 중에서도 Redis를 이용한 분산락 적용을 고려하게 되었습니다.


> **문제 상황**


쿠폰 발급 기능과 예약 기능을 구현했으나 동시에 많은 사용자가 요청하는 것을 가정하고 작성한 테스트코드가 실패하였습니다.

발급 가능 수량보다 더 많은 쿠폰이 발급되었고, 동시에 같은 날짜에 같은 공간이 예약되는 문제가 발생했습니다.

또한 예약을 하면서 쿠폰을 사용할 때에도 동시에 같은 쿠폰을 서로 다른 예약에 대해서 사용하는 것도 가능하다는 문제도 발견하였습니다.


> **의견 조율**



동시성 제어가 필요하다라는 것에는 모두가 공감하였고, 어떤 락을 적용할지에 대해서 고민하는 시간을 가지게 되었습니다.

데이터베이스 락의 경우를 먼저 고려해보았는데 성능 저하가 우려되기도 하였고, 예약의 경우는 INSERT에 대해 락을 걸어야 하기 때문에 DB 락을 이용할 수 없었습니다. 또한 데드락 방지도 신경써야한다는 점도 무시할 수 없었습니다.

그런 다음에는 Redis를 이용한 분산락을 고려하게 되었습니다. Redis의 경우는 싱글 쓰레드를 기반으로 동작하기 때문에 쿠폰 발급하기 기능에서 일어나기 쉬운 경쟁 상태(Race Conditon) 문제를 제어하기 쉽다는 장점도 있고 In-Memory 방식으로 동작하기 때문에 속도가 빠르다는 장점도 있습니다.

또한 Scale-out 상황도 고려하고 있기 때문에 데이터베이스 락보다 훨씬 분산락 구현이 용이하다는 장점도 결정에 영향을 미쳤습니다.

결론적으로 Redis는 DB 락에 비해 성능 저하도 적고, 분산락도 효율적으로 구현할 수 있다는 큰 장점이 있다고 생각하여 Redis를 이용한 분산락을 적용하기로 결정하였습니다.


> **결정**



선착순 쿠폰 발급 같은 기능에는 순간적으로 많은 트래픽이 몰릴 가능성이 있습니다. 데이터베이스 락의 경우는 이런 상황에서 커넥션 풀 고갈로 인한 성능 저하가 우려되는 등 여러 이유로 Redis를 활용한 분산락을 적용하기로 선택하였습니다.

Redis를 활용한 분산락은 쿠폰 발급 및 예약 시 발생할 수 있는 동시성 문제를 효과적으로 해결할 수 있었고, 성능 저하도 최소화할 수 있다는 장점이 있었습니다.

따라서 Redis를 활용한 분산락을 구현하기로 최종 결정하였습니다.

</details>

<details>
<summary><h3>Lettuce와 Redisson중에 어떤 것을 사용할 것인가?</h3></summary>


> **배경 및 둘의 장단점 비교**

Redis를 이용하여 분산 락을 구현하기로 하여, 이를 위한 라이브러리로 Lettuce와 Redissson을 고려했습니다.

Lettuce는 스프링 부트에서 기본으로 제공되기 때문에 구현이 쉽게 가능하지만 스핀 락 방식을 이용하기 때문에 비효율적일 수 있다고 생각했습니다.

반면, Redisson은 Pub/Sub을 활용한 락을 제공하기 때문에 더 효율적인 구현이 가능합니다.

**- Lettuce** : 스핀 락을 사용하여 락을 획득할 때까지 계속 반복적으로 락 획득을 시도합니다. 이 방식은 요청이 많아질수록 부하가 커지는 단점이 있습니다.

**- Redisson** : Pub/Sub을 이용한 락 구현을 제공합니다. 락을 얻지 못할 경우 락 해제 이벤트를 대기하게 되며, 이벤트 발생시에만 다시 락 획득을 시도합니다. 이로 인해 부하가 줄어들어 더 효율적입니다.


> **의견 조율**

많은 트래픽이 순간적으로 몰리는 상황을 가정하면, Redisson이 Lettuce보다 더 효율적이라고 판단했습니다. 

Redisson의 이벤트 기반 락 해제 감지 기능은 Redis 서버에 가해지는 부하를 줄여주기 때문에, 대규모 트래픽 환경에서도 성능 저하를 최소화할 수 있을 것이라고 의견이 모여졌습니다.


> **결정**

분산락을 도입하려는 기능인 선착순 쿠폰 발급의 특성상 많은 트래픽이 순간적으로 몰리게 되는 상황을 가정하고 이에 더 효율적인 Redisson을 사용하기로 결정했습니다.

</details>

<details>
<summary><h3>어디에 캐시를 적용할 것인지?</h3></summary>

> **도입**

모니터링 결과 특정 API들의 성능 저하를 확인할 수 있었습니다. 인기 공간 TOP4를 불러오는 API가 가장 느렸고, 검색 API 역시 많이 느렸기 때문에 캐시 도입을 고려하게 되었습니다.

이 과정에서 캐시를 어디에, 어떻게 적용할 지 결정해야했습니다.


![image](https://github.com/user-attachments/assets/e3fdf285-c944-460f-b888-e36954f39f8c)


> **문제 상황**

Redis 인프라는 이미 구축되어있는 상황이었고, 캐시 도입을 하기로 결정하였지만 어디에 캐시를 적용할 것인지를 결정해야하는 상황이었습니다.

성능이 잘 나오지 않는 부분에 적용해야한다는 것은 명확했지만 어디에 어떤 방식으로 캐시를 적용할 것인지를 결정해야했습니다.


> **의견 조율**

캐시 도입 대상을 선정하는 과정에서 여러 논의가 있었는데 주로 생각했던 부분은 캐시 도입으로 인해 성능이 크게 향상되는가와 데이터 일관성에 큰 영향을 미치지 않는지 여부였습니다.

따라서 ’최근 일주일 간 가장 예약이 많은 공간’을 불러오는 API의 경우에는 쉽게 캐시 도입을 결정할 수 있었습니다. 쉽게 바뀌지 않는 부분이어서 데이터 일관성 문제도 적고, 캐시 도입으로 성능 또한 크게 향상될 수 있는 부분이었기 때문입니다.

반면 검색 API의 경우에는 캐시 적용이 어렵다는 결론을 내렸습니다. 공간이 새로 등록되었을 때 캐시가 업데이트 되어야한다는 점도 이유 중 하나였고, 무엇보다도 검색 API의 경우는 사용자마다 매우 다양한 필터링 조건을 적용할 수 있고, 페이지별로도 결과가 달라지기 때문에 수많은 캐시 키를 관리해야하는 문제가 있었습니다. 

이런 이유로 검색 API에는 캐시를 적용하지 않기로 결정했습니다.

또한 인기 검색어 TOP 10을 불러오는 API에도 캐시를 적용하는 것에 대해도 논의를 했었는데 결론적으로는 현재 성능상 아무런 문제가 없기 때문에 캐시를 도입할 필요를 느끼지 못하여 적용하지 않기로 결정하였습니다. 또한 실시간으로 인기 검색어 순위가 바뀌었으면 좋겠다고 생각하여 데이터 일관성 문제로 인한 손실이 더 크다고 판단하였습니다.

스케줄러를 이용해 며칠 지난 검색어는 모두 삭제하고 있기 때문에 큰 성능 문제가 앞으로도 발생하지 않을 것으로 예상되기 때문에 더 쉽게 결정할 수 있었습니다.


> **결정**

’최근 일주일 간 가장 예약이 많은 공간’을 불러오는 API에만 캐시를 도입하는 것으로 최종 결정되었습니다. 캐시 적용으로 인한 큰 성능 향상이 있으면서도, 데이터 일관성 문제로 인한 영향도 거의 없는 부분이라고 생각했기 때문입니다..

검색 API의 경우에는 다양한 필터링 조건과 페이지에 따라 캐싱 기준이 복잡하고 모호하기 때문에 그리고 실시간으로 데이터가 변경될 가능성이 적지 않기 때문에 캐시 적용에서 제외하였습니다.

인기 검색어의 경우는 현재 큰 성능저하가 없기 때문에 데이터 일관성 문제로 인한 손실이 더 크다고 판단해 캐시 도입을 결정하지 않았습니다.

</details>

<details>
<summary><h3>왜 CI/CD를 적용하는 것인지?</h3></summary>

> **도입**


개발 과정에서 반복적인 작업을 줄이고, 효율성을 높이기 위해 CI/CD 파이프라인을 구축하게 되었습니다.


> **문제 상황**


각자 맡은 이슈를 브랜치로 나눠 작업한 후 머지를 진행하는 과정에서, 전체 테스트 코드가 실패하는 상황이 발생했습니다. 푸시 전에 테스트 통과를 확인해야 했지만, 이를 잊고 푸시하여 문제가 생긴 것입니다. 또한, 서버 배포 후 수정 사항이 발생할 때마다 수동으로 재배포해야 하는 반복 작업도 큰 비효율을 초래했습니다. 이 두 문제를 해결하기 위해 자동화된 테스트 및 배포를 위한 CI/CD 파이프라인을 도입하기로 결정했습니다.


> **의견 조율**


CI/CD 파이프라인을 구축하기 위해 Jenkins와 GitHub Actions 두 가지 옵션을 고려했습니다. Jenkins는 세밀한 기능과 UI 커스터마이징이 가능하지만, 설정이 복잡하고 별도의 인프라 구축이 필요했습니다. 

반면, GitHub Actions는 GitHub에서 제공하는 클라우드 서비스를 통해 별도의 인프라 없이도 쉽게 설정이 가능하며, 기존에 만들어져 있는 다양한 액션을 활용할 수 있다는 장점이 있었습니다. 

현재 프로젝트는 복잡한 배포 과정을 필요로 하지 않았고, 인프라 구축의 필요성을 줄이기 위해 GitHub Actions를 선택했습니다.


> **결정**


GitHub Actions를 이용하여 CI/CD 파이프라인을 구축했습니다. dev 및 main 브랜치에 PR 시 자동으로 테스트 코드를 실행하고, 모든 테스트를 통과해야만 머지가 가능하도록 제한했습니다. 

또한, main 브랜치에 푸시할 경우 자동으로 배포가 진행되도록 설정하여 수동 반복 작업을 제거했습니다.

</details>

<details>
<summary><h3>어떤 식으로 로깅/모니터링을 할 것인지?</h3></summary>


> **도입**


원활한 서비스 운영과 유지보수를 위해 모니터링 및 로깅 시스템을 구축하였습니다.


> **문제 상황**


서비스 배포 후 발생한 버그의 원인을 추적하기 위해 배포된 서버에 직접 접속하여 로그를 확인했지만, 운영 환경에서 의미 있는 정보를 얻기 어려워 원인 파악이 힘들었습니다. 이로 인해 유지보수를 위해 유의미한 로그를 남기고 이를 효과적으로 관리할 수 있는 시스템이 필요하다고 판단했습니다. 또한, 서비스 개선을 위해 응답 시간, 메모리 사용량, 스레드 풀 상태 등 다양한 메트릭을 모니터링할 필요도 있었습니다.


> **의견 조율**


실시간 메트릭과 로그를 확인할 수 있도록 로깅 및 모니터링 시스템을 도입하기로 결정한 후, 각각 어떤 기술을 사용할지 논의했습니다. 

모니터링은 오픈 소스인 Prometheus와 Grafana 조합을 사용하기로 했습니다. Prometheus는 Spring Actuator와 쉽게 연동 가능하며, 서버에 부담이 적은 pull 방식을 사용한다는 장점이 있습니다. Grafana는 다양한 데이터 소스를 지원하고, 시각화된 대시보드를 쉽게 구성할 수 있어 선택했습니다.

로깅 시스템의 경우, ELK 스택과 PLG 스택을 두고 고민했습니다. ELK 스택은 ElasticSearch를 사용해 복잡한 쿼리를 지원하지만, 메모리와 디스크 공간을 많이 차지하는 단점이 있습니다. 반면, PLG 스택은 Loki를 사용해 구축이 쉽고 가볍다는 장점이 있지만, 쿼리 기능이 제한적입니다. 현재 모니터링을 위해 Grafana를 사용 중이고, AWS 프리 티어로 EC2 인스턴스 사양이 낮은 점을 고려해, 가벼운 PLG 스택을 선택했습니다. 복잡한 쿼리의 필요성도 낮다고 판단했습니다.


> **결정**


API 요청/응답에 대한 정보를 로깅하고, 스프링 애플리케이션과 동일한 인스턴스에 Promtail을 구축해 로그 파일을 추적하도록 설정했습니다. Prometheus, Grafana, Loki는 EC2 사양과 확장성을 고려해 별도의 EC2 인스턴스에 구축했습니다. Grafana를 사용해 스프링 애플리케이션의 메트릭과 로그를 모니터링할 수 있는 대시보드를 구성했습니다. 또한, Route53을 통해 대시보드 접근을 위한 도메인을 연결해 쉽게 접근할 수 있도록 했으며, 보안을 위해 IP 기반 접근 제한을 설정해 팀원 외의 접근을 차단했습니다.

</details>


## 트러블 슈팅
<details>
<summary><h3>CORS 문제 발생</h3></summary>

> 문제
 
클라이언트에서 서버로 요청을 보내도 CORS 정책에 의해 막혔다는 문구가 뜨면서 정상적으로 정보를 불러올 수 없었는 문제가 발생했습니다  

 
![image](https://github.com/user-attachments/assets/7ff9db09-898e-4602-862e-61b20b10deed)

> 원인

CORS 문제의 근본적인 원인은 브라우저의 SOP(동일 출처 정책, Single Origin Policy). 서버끼리 리소스 공유가 가능하도록 합의된 출처들 간에만 리소스 공유를 허용해주기위한 CORS 설정을 해주지 않았기 때문에 위의 오류가 발생하였습니다

> 해결 과정

해결법 자체는 간단한 검색만으로도 쉽게 찾을 수 있었고, 적용하는 것도 어렵지 않았습니다

단순히 해결법만 알고 넘어가기보다는 문제가 발생한 근본적인 이유를 이해하기 위해 노력하였습니다

위 문제 이후에도 S3 이미지 저장소의 PresignedUrl을 이용할 때도 CORS 문제가 발생하였는데, 원인을 알고있다보니 어디를 수정해야할지 파악하기가 쉬웠습니다. S3 저장소의 설정에 들어가서 CORS 설정만 해주면 되었습니다.

> 해결 방법

Spring Security를 이용하고 있기 때문에 SecurityConfig 파일에 있는 FilterChain에 다음과 같이 CORS 설정을 위한 코드를 추가해주는 것으로 쉽게 CORS 설정이 가능하였습니다

설정이 간단했기 때문에 아래와 같이 작성하였지만, 설정이 복잡해지거나 해당 내용을 재사용할 필요가 생기는 경우에는 따로 Config 파일을 만들어 Bean으로 등록해 사용해면 좋을 것 같습니다
 
 
```sql
@Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        return http
            .cors { cors ->
                cors.configurationSource {
                    val configuration = CorsConfiguration()
                    configuration.allowedOrigins =
                        listOf("https://bean-space-front.vercel.app/")
                    configuration.allowedMethods = listOf("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
                    configuration.allowedHeaders = listOf(
                        "X-Requested-With",
                        "Content-Type",
                        "Authorization",
                        "Origin",
                        "Accept",
                        "Access-Control-Request-Method",
                        "Access-Control-Request-Headers"
                    )
                    configuration.allowCredentials = true
                    configuration
                }
            }
            .httpBasic { it.disable() }
            // ... 중략
``` 
</details>

<details>
<summary><h3>예약시 쿠폰을 넣지 않으면 오류가 발생하는 문제</h3></summary>

> **문제**

예약할 때 유저가 쿠폰이 없을 수도 있고, 쿠폰을 적용하지 않을 수도 있는데도 불구하고 반드시 쿠폰이 있어야만 예약이 되는 문제가 발생하였습니다.


> **원인**

원인은 단순히 쿠폰을 적용한 경우와 아닌 경우를 구분하여 코드를 작성해야했는데 반드시 필요하다고 가정하고 코드를 작성했기 때문입니다.


> **해결 과정**

예약의 경우는 프로젝트에서 가장 핵심기능이었고 많은 예외처리와 복잡한 로직이 들어있었기 때문에 신경써야할 부분이 많았습니다.

때문에 쿠폰을 적용하고 쿠폰 적용에 맞춰 계산하는 것에 초점을 맞추다보니 쿠폰이 없는 경우를 완전히 놓치고 코드를 작성한 것을 코드 리뷰와 테스트 과정에서 발견하였습니다.

쿠폰이 없는 경우에 대해서 다시 코드를 작성함으로써 문제를 해결할 수 있었습니다.


> **해결 방법**

쿠폰이 없는 경우 Request에서 쿠폰을 보내지 않게 만들었습니다.(Nullable로 만듬)

Safe Call을 활용하여 Request에서 쿠폰 ID가 null일 경우 체이닝으로 모든 호출을 건너뛰도록 코드를 작성하였습니다.

Request에 쿠폰 ID가 비어있다면 거의 모든 과정을 건너 뛰도록 코드를 작성하여 쉽게 문제를 해결할 수 있었습니다. 

```kotlin
val userCoupon = request.userCouponId?.let {
                    val couponKey = "userCoupon:$it"
                    couponLock = redissonClient.getLock(couponKey)

                    try {
                        if (!couponLock!!.tryLock(5, 10, TimeUnit.SECONDS)) {
                            throw IllegalStateException("이미 사용중인 쿠폰입니다.")
                        }
                        log.info { "LOCK COUPON KEY : $couponKey" }

                        userCouponRepository.findByIdOrNull(it)
                            ?: throw ModelNotFoundException("UserCoupon", it)
                    } catch (e: RuntimeException) {
                        couponLock?.unlock()
                        couponLock = null
                        throw e
                    }
                }?.also {
                    check(it.isCouponUnused()) { throw IllegalStateException("이미 사용한 쿠폰입니다.") }
                }?.also {
                    check(it.coupon.isNotExpired()) { throw IllegalStateException("쿠폰의 유효기간을 확인해주세요.") }
                }
```
</details>


<details>
<summary><h3>삭제된 리뷰가 표시되는 문제와 리뷰 삭제 이후 리뷰 작성 가능 표시 오류 문제</h3></summary>

> **문제**

리뷰를 삭제해도 여전히 조회되는 문제를 발견하였습니다.

또한 리뷰는 하나의 예약에 대해 하나의 리뷰만 작성 가능하도록 되어있고 정책상 리뷰 삭제 이후에 다시 리뷰 작성이 불가능했으나, 리뷰 작성 가능 여부를 조회시 리뷰 삭제 이후에도 리뷰가 작성 가능하다고 표시되는 문제가 있었습니다.


> **원인**

Soft Delete를 이용해 삭제를 구현했는데 조회 과정에서 삭제 여부를 확인하지 않고 조회를 하고 있어 삭제된 리뷰가 노출되는 것이 원인이었습니다.

위의 문제가 고쳐진 이후에 다른 문제가 발생했는데, 리뷰 작성 가능 여부를 조회할 때 해당 예약에 대한 리뷰가 존재하는지를 조회하게 되는데, 이때에는 Soft Delete로 삭제된 리뷰도 조회가 되야하지만 @SQLRestriction 어노테이션을 이용해 Soft Delete를 구현하였다보니 이때에는 또 조회가 되지 않아서 리뷰가 다시 작성 가능한 것 처럼 표시되는 문제가 발생하였습니다.


> **해결 과정**

먼저 리뷰를 삭제해도 여전히 리뷰가 노출되는 문제를 해결하는 건 쉽게 해결이 가능했습니다.

@SQLRestriction이라는 어노테이션을 활용하여 조회시 삭제된 리뷰가 모두 조회되지 않도록 쉽게 만들 수 있었습니다.


```kotlin
@Entity
@SQLRestriction("is_deleted = false")
class Review(
    @Column
    var content: String,
    
// ...중략
```

하지만 위와 같이 만들었더니 문제가 하나 생겼는데 Soft Delete로 삭제된 리뷰도 조회해야할 경우가 있었기 때문입니다.

하나의 예약에 대해 하나의 리뷰만 작성할 수 있는데, 한 번 리뷰를 작성했다가 삭제하면 그 이후에는 리뷰를 다시 작성할 수 없도록 만들어야 했습니다.

리뷰를 작성했는지 여부를 내보내줘야해서 해당 예약에 대해 리뷰가 있나 없나를 조회해야 했는데 @SQLRestriction 때문에 이때 리뷰가 달려있지 않다고 조회가 되는 문제가 발생했습니다.

위 문제를 해결하기 위해서 위의 @SQLRestriction을 건너뛰고 쿼리가 발생하도록 NativeQuery를 작성하기로 하였습니다.

```kotlin
@Query("SELECT reservation_id FROM review WHERE reservation_id IN (:reservationIds)", nativeQuery = true)
    fun findReservationIdsByReservationIdIn(reservationIds: List<Long>): List<Long>
```

 위와 같이 NativeQuery를 직접 작성하여 Soft Delete로 삭제된 리뷰도 조회가 가능하였고 정상적으로 리뷰 작성 가능 여부를 응답으로 내보낼 수 있었습니다.


> **해결 방법**

@SQLRestriction 이라는 어노테이션을 이용해 삭제된 리뷰가 조회되지 않도록 만들었습니다.

위의 어노테이션을 건너뛰고 삭제된 리뷰도 조회가 되어야하는 경우에는 NativeQuery를 직접 작성하여 문제를 해결하였습니다.

</details>

<details>
<summary><h3>분산락 적용 이후에도 쿠폰이 초과 발급되는 문제</h3></summary>

> **문제**

Redis를 이용한 분산락을 적용하였지만 여전히 동시성 제어 확인을 위해 만든 테스트를 통과하지 못했습니다.


락 적용 이전보다는 훨씬 나아진 결과를 보여주었지만 (200장 발급되어야할 쿠폰이 300장씩 발급 되던게 205장으로 줄어듬) 여전히 동시성 문제가 발생하였습니다.

![image](https://github.com/user-attachments/assets/c8640b76-02c7-4a76-87ba-8fed3b849a62)



> **원인**


로그를 확인하니 스레드별로 락이 걸려있는건 맞으나 쿼리가 커밋되는 시점이 락이 해제된 후였습니다.

락이 해제되고 쿼리가 커밋되는 시간 사이에 다른 스레드가 접근하게 되어 발생한 문제입니다.

아래처럼 락이 해제되는 시점과 트랜잭션이 종료되는 시점 사이에 다른 요청이 들어오게 되면 커밋 되기 전 데이터를 조회하고 변경하게 됩니다.

```kotlin
**1. 트랜잭션 시작

2. 락을 획득하는 시점

3. 쿠폰 발급

4. 락이 해제되는 시점

(이 짧은 찰나에 들어온 요청은 커밋이 되기 전의 데이터를 조회하게 됨)

5 .트랜잭션 종료(커밋 시점)**
```


> **해결 과정**



먼저 문제 파악이 굉장히 어려웠습니다. 분명 결과만 보아도 동시성 제어가 되고 있는 것 같은데 일부만 실패를 하게되니 원인 파악이 쉽지 않았습니다.

로그를 자세히 살펴보고 오랜 시간 고민과 검색 끝에 해당 문제를 파악할 수 있었습니다.

로그를 자세히 확인하니 스레드별로 락이 걸린것은 확인되었지만 커밋 전에 락을 획득한다는 것을 알 수 있었습니다.

트랜잭션 범위를 조정해야한다는 것을 알게되었고, 어떻게 조정할지 여러 방법을 찾아본 후에 하나를 적용해서 문제를 해결할 수 있었습니다.

문제가 해결된 이후에는 정상적으로 미리 작성해 둔 테스트 코드가 모두 통과하였습니다.

![image](https://github.com/user-attachments/assets/4ed89a8a-8c26-4940-be67-6a2b15133756)



> **해결 방법**

락이 해제된 이후에 트랜잭션이 종료되고 커밋이 되도록 코드를 다시 작성하였습니다.

아래와 같이 작동하도록 코드를 수정하였습니다.


```kotlin
트랜잭션 시작

락이 걸리는 시점

트랜잭션 종료(커밋 시점)

락이 해제되는 시점
```

찾아본 결과 `TransactionTemplate`  이라는 것을 이용해 쉽게 트랜잭션 범위를 원하는 대로 만들 수 있다는 것을 알게 되었고 이것을 이용해 코드를 수정하여 문제를 해결하였습니다.

```kotlin
fun issueCoupon(memberId: Long, couponId: Long) {
    val key = "coupon:$couponId"
    val lock = redissonClient.getLock(key)

    try {
        if (!lock.tryLock(5, 10, TimeUnit.SECONDS)) throw IllegalStateException("쿠폰 발행을 다시 시도해주세요")

        transactionTemplate.execute {
            /*
            쿠폰 발급 로직
            */
        }
    } finally {
        if (lock.isHeldByCurrentThread) {
            lock.unlock()
        }
    }
}
```
</details>

<details>
<summary><h3>Time Zone에 의한 문제 발생</h3></summary>

> **문제**



발급 시작된 쿠폰이 발급되지 않는 문제가 발생하였습니다.


> **원인**


![image](https://github.com/user-attachments/assets/d5a91802-9466-4116-94bc-d7a930612a7c)


DB와 서버의 타임존이 일치하지 않아 발생한 문제였습니다. DB는 Asia/Seoul 타임존으로 시간이 저장되어 있었으나, 서버는 UTC를 사용하고 있어 `LocalDateTime.now()`로 시간을 체크할 때 9시간의 오차가 발생하였습니다.


> **해결 과정**


서버 로그를 확인하여 쿠폰 발급 요청 시간과 로그에 기록된 시간을 비교해보니 9시간의 차이가 있는 것을 확인했습니다. 서버의 `LocalDateTime` 기준이 UTC로 설정되어 있다는 것을 파악하고, 문제 해결 방법을 찾기 시작했습니다. 스프링 부트의 기본 타임존 설정을 Asia/Seoul로 변경하면 문제가 해결된다는 것을 알게 되었고, 이를 적용하여 문제를 해결했습니다.


> **해결 방법**


스프링부트의 기본 TimeZone 설정을 Asia/Seoul로 변경하여 문제를 해결하였습니다.
아래와 같이 코드를 작성하여 타임존을 설정할 수 있습니다.

```kotlin
@SpringBootApplication
class BeanSpaceApplication

fun main(args: Array<String>) {
		//Default TimeZone 설정
    TimeZone.setDefault(TimeZone.getTimeZone(ZoneId.of("Asia/Seoul")))
    runApplication<BeanSpaceApplication>(*args)
}
```

위 코드를 적용하면 서버의 타임존이 Asia/Seoul로 설정되어 DB와 서버 간의 시간 차이가 발생하지 않게 됩니다.

</details>

<details>
<summary><h3>너무 느린 메인 페이지 로딩과 검색 문제</h3></summary>

> **문제**

데이터 개수가 적을 때는 별 문제가 없었으나 더미 데이터를 만들어 데이터 양을 많이 늘렸더니 메인 페이지 로딩과 검색 기능의 성능이 느려진 게 체감되기 시작하였습니다.

배포 이후 테스트 유저 사이에서도 메인 페이지 로딩이 너무 느리다라는 피드백도 있었습니다.


> **원인**

더미 데이터의 개수가 많아지니 메인 페이지에 있는 ‘가장 예약이 많은 공간 TOP4’ 부분과 검색 기능이 많이 느려져 로딩 시간이 길어졌습니다.

해당 부분들이 서비스 전체에서 가장 오랜 시간이 걸리는 쿼리들이었고 메인 기능이었기 때문에 더 눈에 띄는게 문제였습니다.

구현을 우선순위로 삼고 성능 최적화를 진행하지 않고 배포했기 때문에 위와 같은 문제가 발생하였습니다.


> **해결 과정**

성능최적화의 필요성이 명확해졌기 때문에 차근차근 최적화를 진행하게 되었습니다.

먼저 불필요한 JOIN이라던가 효율적이지 못한 쿼리가 발생하지 않는지를 차근차근 살펴보게 되었습니다.

복잡한 쿼리 하나를 조금이나마 간단하게 만들 수 있었습니다.

그런 다음 인덱스를 만들어 조회 성능을 끌어올릴 수 있는지 적용해보고 테스트하는 시간을 가졌습니다.

그리고 자주 데이터가 변하지 않는 부분에 대해서는 캐시 도입을 고려하였고, 캐시를 도입하여 성능을 크게 향상 시킬 수 있었습니다.


> **해결 방법**

QueryDsl로 작성한 쿼리들을 직접 확인하여 어떤 쿼리들이 발생하는지를 쭉 살펴보았습니다.

그 중에서 어떤 쿼리가 오래 걸리는지 파악한 뒤 해당 쿼리들을 수정하기도 했고, 쿼리를 보면서 자주 발생하는 쿼리와 오래 걸리는 쿼리에 인덱스를 적용하여 쿼리 성능을 크게 끌어올릴 수 있었습니다.

예시) 자주 발생하는 쿼리들


```sql
SELECT DISTINCT s.id, AVG(r.rating) AS rating
  FROM space s
     LEFT JOIN review r ON r.space_id = s.id AND r.is_deleted = false
WHERE s.status = 'ACTIVE'
  AND s.id NOT IN (
    SELECT space_id
    FROM reservation
    WHERE check_in < '2024-08-18'
       AND check_out > '2024-08-17'
       AND is_cancelled = false
        )
  AND s.max_people >= 1
  AND s.is_deleted = false
GROUP BY s.id
ORDER BY rating DESC, s.id DESC;
```

```sql
SELECT DISTINCT s.id, COUNT(r.id) AS count
FROM space s
  LEFT JOIN reservation r ON r.space_id = s.id
    AND r.is_cancelled = false
    AND r.created_at >= '2024-08-09'
WHERE s.status = 'ACTIVE'
  AND s.id NOT IN (
    SELECT r2.space_id
    FROM reservation r2
    WHERE r2.check_in < '2024-08-18'
       AND r2.check_out > '2024-08-17'
    AND r2.is_cancelled = false
)
  AND s.max_people >= 1
  AND s.is_deleted = false
GROUP BY s.id
ORDER BY count, s.id DESC;
```

아래 처럼 실행 계획도 확인하여 인덱스가 잘 활용되고 있는지도 확인하였습니다.

![image](https://github.com/user-attachments/assets/d38de410-3bb5-4b1f-b8ac-becadd02cbc3)


또한 자주 변하지 않는 부분인 메인페이지의 ‘최근 일주일 가장 예약이 많은 숙소 TOP4’에는 스케줄러를 이용해서 일정 시간마다 캐시를 업데이트 시켜주고 조회할 때는 캐시에서 불러오는 식으로 만들어 크게 끌어올릴 수 있었습니다.

***성능 최적화 이전 평균 응답 시간**

검색 기능: 1.01 초
가장 예약 많은 숙소 TOP 4: 1.41 초*

***성능 최적화 이후 평균 응답 시간**

검색 기능: 0.42 초 (1.01초 → 0.42초) **약 60% 응답시간 감소**
가장 예약 많은 숙소 TOP 4: 0.281초 (1.41초 → 0.281초) **약 80% 응답시간 감소***

![image](https://github.com/user-attachments/assets/63d6ddfc-0f81-4e9a-abd0-410761a6601f)


![image](https://github.com/user-attachments/assets/cfabf4e2-276e-4009-9933-caeb782955d8)


</details>

<details>
<summary><h3>Email 인증 안해서 도메인 정지된 문제</h3></summary>

> **문제**

사이트 배포가 완료되고 유저 테스트를 진행하던 중 새벽에 갑자기 사이트 접속이 불가능한 문제가 발생하였습니다.


> **원인**



Route 53에 새 도메인을 등록하는 경우 등록자의 E-mail 주소가 유효한지 확인이 필요합니다. AWS에서 확인을 위한 이메일 링크를 보내주는데 15일 안에 이 링크를 클릭하지 않으면 도메인이 일시 중지 됩니다.

![image](https://github.com/user-attachments/assets/b1cb47cc-8b95-48e0-8f8e-ffd2099cb13d)


이 부분을 놓쳐서 도메인이 일시 중지되어 사이트 접속이 불가능하였습니다.


> **해결 과정**

갑자기 사이트에 접속이 불가능했고, 서버는 정상적으로 동작중이었기 때문에 원인을 파악하기가 쉽지 않았습니다.

사이트에 접속하면 ‘DNS_PROBE_FINISHED_NXDOMAIN’라는 문구가 떴고 해당 문구는 도메인 이름을 IP 주소로 변환할 수 없을 때 발생한다는 것을 힌트로 삼아 문제를 찾기 시작하였습니다.

원인을 파악하기 위해 AWS 이곳저곳에 접속하는 등 꽤 오랜 시간을 보내던 와중에 Route 53에 접속했다가 E-mail 미인증으로 인해 도메인이 Suspension(일시 중지) 되었다는 문구를 발견할 수 있었습니다.

E-mail 재발송을 요청한 뒤 인증하였더니 문제를 쉽게 해결할 수 있었습니다.



![image](https://github.com/user-attachments/assets/24a81510-3aa7-4d08-b6fe-42b91382108c)



> **해결 방법**

E-mail 재발송을 요청한 뒤 인증하였더니 1시간 안으로 도메인이 복구 되었습니다.
****


![image](https://github.com/user-attachments/assets/779f4598-e292-4275-94d9-ca9190929359)


</details>

<details>
<summary><h3>502 BadGateway</h3></summary>

> **문제**


서버 배포후 접속을 시도했으나 502 BadGateway 오류가 발생하였습니다.


> **원인**


Nginx 설정 문제였습니다. Elastic Beanstalk 생성시 Docker 기반으로 플랫폼을 설정하면서 `proxy_pass`가 `http://docker`로 지정되어 있었고, Nginx가 이 대상을 찾지 못해 오류가 발생했습니다.


> **해결 과정**


502 Bad Gateway 오류 메시지를 통해 Nginx가 관련된 문제임을 알게 되었습니다. Nginx를 별도로 설치하지 않았기 때문에 왜 이 오류가 발생했는지 확인해보니, AWS Elastic Beanstalk로 EC2를 설정할 때 기본적으로 Nginx가 설치된 것이 원인이었습니다. Nginx 설정 문제임을 인지하고 설정 파일을 확인했습니다. 기본 설정 파일 내용은 아래와 같았습니다.

```
...
server {
        listen 80 default_server;
        gzip on;
        gzip_comp_level 4;
        gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

        access_log    /var/log/nginx/access.log main;

        location / {
            proxy_pass            http://docker;
            proxy_http_version    1.1;
            proxy_set_header    Connection             $connection_upgrade;
            proxy_set_header    Upgrade                $http_upgrade;
            proxy_set_header    Host                   $host;
            proxy_set_header    X-Real-IP              $remote_addr;
            proxy_set_header    X-Forwarded-For        $proxy_add_x_forwarded_for;
        }
    ...
```

`proxy_pass` 가 `http://docker` 로 되어있었습니다.


> **해결 방법**


Docker 컨테이너를 실행할 때 `docker run -p 5000:8080` 명령어를 사용해 Tomcat의 8080 포트를 외부의 5000 포트로 연결했습니다. 이후, Nginx 설정 파일의 `proxy_pass` 값을 `http://localhost:5000`으로 수정했습니다.

```
...
server {
        listen 80 default_server;
        gzip on;
        gzip_comp_level 4;
        gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

        access_log    /var/log/nginx/access.log main;

        location / {
            proxy_pass            http://localhost:5000;
            proxy_http_version    1.1;
            proxy_set_header    Connection             $connection_upgrade;
            proxy_set_header    Upgrade                $http_upgrade;
            proxy_set_header    Host                   $host;
            proxy_set_header    X-Real-IP              $remote_addr;
            proxy_set_header    X-Forwarded-For        $proxy_add_x_forwarded_for;
        }
    ...
```

이렇게 설정함으로써 로드 밸런서를 통해 들어온 HTTP 요청이 Nginx를 거쳐 `http://localhost:5000`으로 전달되었고, Docker 컨테이너 내의 Spring 애플리케이션으로 요청이 도달하게 되었습니다. 이후 502 Bad Gateway 오류는 발생하지 않았습니다.


</details>

<details>
<summary><h3>배포 이후 피드백 과정에서 해결한 문제들</h3></summary>

> **문제**

유저 테스트 피드백에 많은 버그들이 제보되었습니다

프론트
- 날짜 선택을 위한 캘린더가 제대로 작동하지 않는 문제
- 엔터키를 이용해 검색이 불가능한 문제
- 정렬 기준을 바꾸어도 페이지가 1로 돌아오지 않는 문제
- 기타 등등

백엔드
- 이미지가 필수가 아님에도 이미지가 없으면 리뷰가 작성되지 않는 문제
- 회원 가입시 이미지 업로드에 실패하는 문제
- 예약 금액이 너무 높아지면 오버플로우가 발생하는 문제


![image](https://github.com/user-attachments/assets/1c2b17e1-72bb-4f39-9058-c5e6d00805d4)



> **원인**

근본적인 원인은 배포 이전 면밀하게 테스트 전체를 돌면서 테스트하지 못해 버그들을 미처 발견하지 못했기 때문입니다.

배포 직전까지도 수정을 거듭했기 때문에 시간이 빠듯했던 것도 원인 중 하나입니다.

유효성 검사의 경우에는 하루 날을 잡아 전체적으로 점검을 했음에도 불구하고, 여러 구멍이 발견되었습니다. 팀 차원에서 더 꼼꼼하게 살펴보고 회의하는 시간을 가졌어야 하지 않았나 하는 아쉬움도 있었습니다.


> **해결 과정**

프론트에는 정말 많은 문제들이 발생하였는데 전부 고치기는 어려웠지만 최대한 고칠 수 있는 부분을 수정하였습니다. 유저의 의견을 최대한 반영해서 유저가 편하게 느낄 수 있도록 힘썼습니다.

*- 이미지가 필수가 아님에도 이미지가 없으면 리뷰가 작성되지 않는 문제*

이미지가 필수가 아니었는데 이미지가 없으면 리뷰가 작성되지 않는 문제가 있다는 피드백이 들어와서 확인해보게 되었습니다. 알고보니 AddReviewRequest 쪽에 이미지부분에@NotEmpty 어노테이션이 걸려있다는 것을 알 수 있었습니다.

해당 부분을 제거하고 이미지가 없이도 리뷰를 등록할 수 있도록 수정하였습니다.

*- 회원 가입시 이미지 업로드에 실패하는 문제*

저희 서비스에는 공간 사진과 리뷰 사진, 프로필 사진등 사진이 여기저기서 이용되는데, PresignedUrl 발급에는 인증이 반드시 필요한 경우만 있다고 생각하여 해당 URI에 요청을 보낼 때 인증이 필요하도록 만든 것이 문제였습니다.

때문에 아직 인증이 되지 않은 회원가입을 시도하려는 유저가 프로필 사진을 회원가입 시에 업로드 하려고 할 때 문제가 발생했던 것이었습니다.

PresignedUrl 발급시 인증이 필요없도록 수정하여 문제를 해결할 수 있었습니다.

*- 예약 금액이 너무 높아지면 오버플로우가 발생하는 문제*

저희가 예약 금액을 계산하는 로직에서 분명 모든 부분을 Long 형으로 변환하는 등 처리를 해놓았기 때문에 오버 플로우가 발생할 수 없다고 생각했는데 유저 테스트에서 이런 경우가 발생하는 것을 확인할 수 있었습니다.

확인 결과 예약 금액을 계산하는 과정 중간에 Int로 계산되는 부분이 있음을 발견하게 되었고 해당 부분에 toLong()을 추가하여 Long 형으로 변환하여 계산하도록 만들어 문제를 해결할 수 있었습니다.
****


> **해결 방법**

프론트의 경우 문제 해결 방법을 자세히 적지는 않겠습니다.

*****- 이미지가 필수가 아님에도 이미지가 없으면 리뷰가 작성되지 않는 문제*

@NotEmpty 어노테이션을 삭제하여 문제를 해결할 수 있었습니다.
****


```kotlin
@field:Size(max = 3, message = "리뷰 이미지는 최대 3개까지 가능합니다.")
val imageUrlList: List<String>,
```

*- 회원 가입시 이미지 업로드에 실패하는 문제*

presignedUrl 발급시 인증이 필요없도록 변경하여 문제를 해결할 수 있었습니다.

SecurityConfig의 RequestMatches에 presignedUrl 발급을 위한 URI를 추가하였습니다.

```kotlin
.requestMatchers(
                        "/healthcheck",
                        "/swagger-ui/**",
                        "/v3/api-docs/**",
                        "/api/v1/auth/sign-up",
                        "/api/v1/auth/login",
                        "/error",
                        "/api/v1/spaces/**",
                        "/oauth2/login/**",
                        "/actuator/prometheus",
                        "/api/v1/images/presigned-url"
                    ).permitAll()
```

*- 예약 금액이 너무 높아지면 오버플로우가 발생하는 문제*

아래 코드에 원래 toLong()이 없었는데 그 부분에서 가격이 너무 높아지면 Int 형 범위를 벗어나 오버플로우가 발생하는 문제가 있었습니다.

계산 중간에 Int 형이 없도록 신경써서 처음에 코드를 작성했음에도 미처 발견하지 못해서 아쉬움이 남았습니다.

```kotlin
fun calculateTotalCost(headCount: Int, stayDays: Long): Long {
        return (this.price + (headCount - this.defaultPeople).coerceAtLeast(0) * this.pricePerPerson.toLong()) * stayDays
    }
```
</details>

## 📂 프로젝트 구조

```
├── BeanSpaceApplication.kt
├── api
│   ├── HealthCheckController.kt
│   ├── admin
│   │   ├── AdminController.kt
│   │   ├── AdminService.kt
│   │   └── dto
│   │       ├── RequestAddSpaceResponse.kt
│   │       └── UpdateSpaceStatus.kt
│   ├── auth
│   │   ├── AuthController.kt
│   │   ├── AuthService.kt
│   │   └── dto
│   │       ├── GetNewAccessTokenRequest.kt
│   │       ├── LoginRequest.kt
│   │       ├── LoginResponse.kt
│   │       └── SignUpRequest.kt
│   ├── coupon
│   │   ├── CouponController.kt
│   │   ├── CouponService.kt
│   │   └── dto
│   │       ├── CouponRequest.kt
│   │       ├── CouponResponse.kt
│   │       └── UserCouponResponse.kt
│   ├── host
│   │   ├── HostController.kt
│   │   ├── HostService.kt
│   │   └── dto
│   │       ├── AddSpaceRequest.kt
│   │       └── UpdateSpaceRequest.kt
│   ├── image
│   │   ├── ImageController.kt
│   │   ├── ImageService.kt
│   │   └── dto
│   │       ├── PreSignedUrlRequest.kt
│   │       └── PreSignedUrlResponse.kt
│   ├── member
│   │   ├── MemberController.kt
│   │   ├── MemberService.kt
│   │   └── dto
│   │       ├── MemberProfileResponse.kt
│   │       ├── MemberReservationResponse.kt
│   │       ├── UpdateProfileRequest.kt
│   │       └── UpdateSocialUserInfoRequest.kt
│   ├── oauth
│   │   ├── KakaoOAuth2Client.kt
│   │   ├── OAuth2LoginController.kt
│   │   ├── OAuth2LoginService.kt
│   │   └── dto
│   │       ├── KakaoLoginUserInfoResponse.kt
│   │       ├── KakaoTokenResponse.kt
│   │       └── KakaoUserPropertiesResponse.kt
│   ├── reservation
│   │   ├── ReservationController.kt
│   │   ├── ReservationService.kt
│   │   └── dto
│   │       ├── ReservationRequest.kt
│   │       └── ReservationResponse.kt
│   └── space
│       ├── SpaceController.kt
│       ├── SpaceService.kt
│       └── dto
│           ├── AddReviewRequest.kt
│           ├── CompactSpaceResponse.kt
│           ├── HostResponse.kt
│           ├── OfferResponse.kt
│           ├── PopularKeywordsResponse.kt
│           ├── ReviewResponse.kt
│           ├── SpaceDetailResponse.kt
│           ├── SpaceResponse.kt
│           ├── SpaceResponseWithoutAddress.kt
│           └── UpdateReviewRequest.kt
├── domain
│   ├── common
│   │   └── BaseTimeEntity.kt
│   ├── coupon
│   │   ├── model
│   │   │   ├── Coupon.kt
│   │   │   └── UserCoupon.kt
│   │   └── repository
│   │       ├── CouponRepository.kt
│   │       ├── CouponRepositoryImpl.kt
│   │       ├── CustomCouponRepository.kt
│   │       ├── CustomUserCouponRepository.kt
│   │       ├── UserCouponRepository.kt
│   │       └── UserCouponRepositoryImpl.kt
│   ├── exception
│   │   ├── AuthenticationException.kt
│   │   ├── GlobalExceptionHandler.kt
│   │   ├── InvalidImageException.kt
│   │   ├── ModelNotFoundException.kt
│   │   ├── NoPermissionException.kt
│   │   └── dto
│   │       └── ErrorResponse.kt
│   ├── image
│   │   ├── model
│   │   │   ├── Image.kt
│   │   │   └── ImageType.kt
│   │   └── repository
│   │       └── ImageRepository.kt
│   ├── member
│   │   ├── model
│   │   │   ├── Member.kt
│   │   │   └── MemberRole.kt
│   │   └── repository
│   │       └── MemberRepository.kt
│   ├── reservation
│   │   ├── model
│   │   │   └── Reservation.kt
│   │   └── repository
│   │       └── ReservationRepository.kt
│   └── space
│       ├── model
│       │   ├── Address.kt
│       │   ├── Offer.kt
│       │   ├── Review.kt
│       │   ├── SearchKeyword.kt
│       │   ├── Space.kt
│       │   ├── SpaceOffer.kt
│       │   ├── SpaceStatus.kt
│       │   └── Wishlist.kt
│       └── repository
│           ├── OfferRepository.kt
│           ├── ReviewRepository.kt
│           ├── SearchKeywordQueryDslRepository.kt
│           ├── SearchKeywordQueryDslRepositoryImpl.kt
│           ├── SearchKeywordRepository.kt
│           ├── SpaceOfferRepository.kt
│           ├── SpaceQueryDslRepository.kt
│           ├── SpaceQueryDslRepositoryImpl.kt
│           ├── SpaceRepository.kt
│           └── WishListRepository.kt
└── infra
    ├── log
    │   └── LogFilter.kt
    ├── querydsl
    │   └── QueryDslConfig.kt
    ├── redis
    │   ├── RedisConfig.kt
    │   └── RedisUtils.kt
    ├── restclient
    │   └── RestClientConfig.kt
    ├── s3
    │   ├── S3Config.kt
    │   ├── S3Service.kt
    │   └── imagevalidator
    │       ├── ImageValidator.kt
    │       └── ValidationResult.kt
    ├── security
    │   ├── CustomAccessDeniedHandler.kt
    │   ├── CustomAuthenticationEntrypoint.kt
    │   ├── config
    │   │   ├── PasswordEncoderConfig.kt
    │   │   └── SecurityConfig.kt
    │   ├── dto
    │   │   └── UserPrincipal.kt
    │   └── jwt
    │       ├── JwtAuthenticationFilter.kt
    │       ├── JwtAuthenticationToken.kt
    │       └── JwtPlugin.kt
    └── swagger
        └── SwaggerConfig.kt
```

## 📌 환경설정
- Language: Kotlin
- IDE: Intellij, VSCode
- SDK: Eclipse Temurin 18.0.2

## 📜 라이선스
이 프로젝트는 MIT 라이선스를 따릅니다. 자세한 내용은 [LICENSE](https://github.com/bean-space/bean-space-front/blob/dev/LICENSE) 파일을 참고하세요.
